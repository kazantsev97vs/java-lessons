package part_3_Java_Multithreading.lesson_18__multithreading___volatile;

import java.util.Scanner;

/**
 *               1-ое ядро     2-ое ядро
 *               +-------+     +-------+
 *               |  CPU  |     |  CPU  |
 *               +---+---+     +---+---+
 *                   |             |
 *               +---+---+     +---+---+     +-------------+
 *               | Cache |     | Cache |     | Main Memory |
 *               +---+---+     +---+---+     +------+------+
 *                   |             |                |
 *        <----------+-------------+----------------+------->
 *     <                 Bus                                   >
 *        <------------------------------------------------->
 *
 *  Допустим у нас есть 2-ух ядерный процессор.
 *  У каждого ядра в процессоре есть свой кеш.
 *  Кеш - это небольшой участок памяти, который у каждого ядра свой,
 *  и в котором хранятся какие-то наиболее свежие и важные данные, которые нужны ядру в данный момент для работы.
 *  Кеш - это участок очень быстрой памяти - быстрее оперативной памяти, и в 100-и раз быстрее памяти на
 *  жестком диске. Но он очень небольшой - несколько мегабайт. Ядро процессора напрямую общается со своим кешем.
 *
 *  У потока MyVolatileThread есть переменная running.
 *  И Может случиться такое, что поток закеширует эту переменную к себе в кеш
 *  и тогда эта переменная всегда будет равняться true.
 *  Даже не смотря на то, что другой поток будет менять эту переменную в дальнейшем,
 *  Для первого потока (он будет продолжать читать значение переменной из своего кеша) она будет всегда true.
 *  Это называется "проблемой когерентности кешей". (кеши не совпадают)
 *
 *  volatile (изменчивый) - гарантирует когерентность кэшей ядер.
 *                         (не дает кэшироваться в памяти ядра -> каждый поток будет обращаться к главной
 *                         памяти, чтобы взять свежее значение переменной)
 *                         Для того случая, когда одна переменная делится между несколькими потоками
 *                         и когда один поток пишет в одну переменную, а другой или более потоков -
 *                         читают из этой переменной тогда с помощью ключевого слова volatile
 *                         - мы можем настроить взаимодействие этих потоков
 */
public class Multithreading_Volatile {


    public static void main(String[] args) throws InterruptedException {

        MyVolatileThread volatileThread = new MyVolatileThread();
        volatileThread.start();

        Scanner scanner = new Scanner(System.in);
        scanner.nextLine();
        volatileThread.shutdown();
    }
}

class MyVolatileThread extends Thread {

    private volatile boolean running = true;

    @Override
    public void run() {

        while (running) {
            System.out.println("Hello");
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    // останавливаем поток
    public void shutdown () {
        this.running = false;
    }
}