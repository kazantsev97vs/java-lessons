package part_3_Java_Multithreading.lesson_19__multithreading___synchronized;

/**
 * Теперь разберем, когда два или более потоков пишут в одну переменную
 * В этом случае volatile работать не будет и нам нужно использовать другую конструкцию
 *
 * У каждого объекта в JAVA после его создания,
 * каждому объекту присваивается какая-то сущность
 * и эта сущность в один момент времени может быть только у одного потока.
 *
 * Ключевое слово synchronized использует эту особенность.
 * только один поток может завлодеть вот этим монитором одного объекта.
 * Вообще монитор используется для того чтобы дать понять JAVA,
 * что данный момент этот поток взаимодействует с объектом,
 * поэтому  другие потоки не должны взаимодействовать с этим объектом,  они должны ждать
 * И монитор нужен для того чтобы поток мог получить доступ к полям объекта или к методам объекта.
 *
 * Синхронизация происходит на каком-то объекте - для синхронизации нужен объект -
 * потому что в Java есть такая особенность, что у всех объектов есть монитор,
 * и монитор в один момент времени может принадлежать только одному потоку.
 */
public class Multithreading_Synchronized {

    private int counter;

    public static void main(String[] args) throws InterruptedException {

        Multithreading_Synchronized multithreadingSynchronized = new Multithreading_Synchronized();
        multithreadingSynchronized.doWork();

    }

    /**
     * Для того чтобы исправить проблему, когда 2 потока пишут в одну переменную
     * существует synchronized - синхронизует работу двух или более потоков при записи в общую переменную
     * это ключевое слово может добавляться только в методах
     *
     * synchronized работает таким образом,
     * что только один поток в один момент времени получает доступ к выполнению тела метода.
     * Т.е. если мы говорим, что метод синхронизованный, то мы говорим, что все,
     * что находится в теле метода может выполнять только один поток в один момент времени.
     * В тот момент, когда один поток исполняет тело метода - другой поток ждёт.
     * Как только оидн поток заканчивает свое выполнение -
     * другой поток, который ждал - ему разрешается исполнить тело метода - и он исполняет его.
     *
     * В данном случае, когда мы не указываем объекты явно, это значит, что мы синхронизируемся на объекте this.
     * В данном случае this - это объект multithreadingSynchronized класса Multithreading_Synchronized
     * multithreadingSynchronized - этот объект мы создали - у него есть какой-то монитор
     * и когда мы методы у этого объекта помечаем ключевым словом synchronized -
     * мы синхронизируемся на this на объекте multithreadingSynchronized, т.е. мы синхронизируемся на его монитрое
     */
    public synchronized void increment() {
        counter++;
    }

    // Ниже второй вариант синхронизации - synchronized-блок и метод идентичный верхнему:
    // public void increment() {
    //     synchronized (this) {
    //         counter++;
    //     }
    // }

    /*
        1: 100 -> 101
        2: 100 -> 101
     */
    public void doWork () throws InterruptedException {

        Thread thread1 = new Thread(new Runnable() {
            @Override
            public void run() {
                // инкрементация
                //      counter++;
                // состоит из трех частей:
                // 1) получить значение
                // 2) произвести сложение
                // 3) присвоить результат переменной counter
                // => операция не атомарна
                // и хотя нам кажется что эти три операции проходят одновременно
                // для процессора они могут занимать разное время и один поток может вырваться вперед,
                // может много раз записать, обновить переменную,
                // в это время другой поток может подождать, замешкаться,
                // а потом обновить переменную тем значением, которое было давным давно,
                // поэтому значения меньше чем 20_000
                for (int i = 0; i < 10_000; i++) increment();
            }
        });

        Thread thread2 = new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 0; i < 10_000; i++) increment();
            }
        });

        /**
         * Метод join() работает следующим образом:
         *      когда мы идем в нашем главном потоке main, поток main доходит до 2ух вызовов ниже,
         *      он мгновенно вызывает эти два потока и если не вызвать join(), то он бы пошел дальше
         *      и вывел бы counter на экран.
         */
        thread1.start();
        thread2.start();

        // Чтобы подождать в нашем потоке других потоков существует метод join()
        /**
         * Но мы хотим подождать пока 2 потока завершат свою работу
         * и только после этого хотим выводить переменную counter на экран.
         * Потому что только после этого мы будем видеть результат этих двух потоков.
         * Чтобы подождать в нашем потоке другие потоки мы вызываем метод join().
         * Когда мы вызываем метод join() - текущий поток останавливается (в данном случае поток main)
         * и ждет пока поток у которого вызван .join() не закончит свою работу,
         * только после этого текущий поток возобновит свою работу.
         */
        System.out.println("Поток main останавливает свою работу и ждет когда thread1 закончит свою работу...");
        thread1.join(); // мы хотим в текущем потоке main подождать пока завершится поток thread1
        System.out.println("Поток main продолжает свою работу...");

        System.out.println("Поток main останавливает свою работу и ждет когда thread2 закончит свою работу...");
        thread2.join(); // мы хотим в текущем потоке main подождать пока завершится поток thread2
        System.out.println("Поток main продолжает свою работу...");

        // counter не равно 20_000 - потому что происходит т.н. "состояние гонки" -
        // 2 потока одновременно обновляют и пишут в одну переменную
        // и часть инструкций (часть инкрементов) - теряется
        System.out.println("Поле counter = " + counter); // 13195
        // теперь всегда потоки работают (обращаются к переменной counter) слаженно и она равняется 20_000
    }
}

